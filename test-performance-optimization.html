<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimization Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }
        .stat-label {
            font-weight: bold;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-top: 5px;
        }
        .controls {
            margin: 20px 0;
        }
        .controls button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .controls button:hover {
            background: #0056b3;
        }
        .controls input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .log-output {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-active { background-color: #28a745; }
        .status-inactive { background-color: #dc3545; }
        .status-warning { background-color: #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Performance Optimization Test Dashboard</h1>
        <p>Test and monitor the collision detection performance optimizations</p>

        <!-- System Status -->
        <div class="test-section">
            <h3>üìä System Status</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">
                        <span id="collision-optimizer-status" class="status-indicator status-inactive"></span>
                        Collision Optimizer
                    </div>
                    <div class="stat-value" id="collision-optimizer-value">Not Initialized</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">
                        <span id="player-debouncer-status" class="status-indicator status-inactive"></span>
                        Player Info Debouncer
                    </div>
                    <div class="stat-value" id="player-debouncer-value">Not Initialized</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">
                        <span id="multi-collision-status" class="status-indicator status-inactive"></span>
                        Multi-Player Manager
                    </div>
                    <div class="stat-value" id="multi-collision-value">Not Initialized</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Game Ready</div>
                    <div class="stat-value" id="game-ready-value">Waiting...</div>
                </div>
            </div>
        </div>

        <!-- Performance Metrics -->
        <div class="test-section">
            <h3>‚ö° Performance Metrics</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Active Collisions</div>
                    <div class="stat-value" id="active-collisions">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Collision Checks/Sec</div>
                    <div class="stat-value" id="checks-per-second">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Average Check Time</div>
                    <div class="stat-value" id="average-check-time">0ms</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Frame Drops</div>
                    <div class="stat-value" id="frame-drops">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Spatial Grid Cells</div>
                    <div class="stat-value" id="spatial-grid-cells">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Queued Updates</div>
                    <div class="stat-value" id="queued-updates">0</div>
                </div>
            </div>
        </div>

        <!-- Test Controls -->
        <div class="test-section">
            <h3>üéÆ Test Controls</h3>
            <div class="controls">
                <button onclick="testCollisionPerformance()">Test Collision Performance</button>
                <button onclick="testPlayerInfoDebouncing()">Test Player Info Debouncing</button>
                <button onclick="testMultiPlayerCollisions()">Test Multi-Player Collisions</button>
                <button onclick="stressTestCollisions()">Stress Test (100 Players)</button>
                <button onclick="clearAllCollisions()">Clear All Collisions</button>
                <br>
                <label>Collision Sensitivity: </label>
                <input type="range" id="sensitivity-slider" min="10" max="200" value="50" onchange="updateCollisionSensitivity(this.value)">
                <span id="sensitivity-value">50px</span>
                <br>
                <label>Max Simultaneous Collisions: </label>
                <input type="number" id="max-collisions" min="1" max="20" value="5" onchange="updateMaxCollisions(this.value)">
            </div>
        </div>

        <!-- Real-time Log -->
        <div class="test-section">
            <h3>üìù Real-time Log</h3>
            <div class="log-output" id="log-output"></div>
            <button onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <script>
        let gameReady = false;
        let updateInterval;
        let logLines = [];

        // Initialize when page loads
        window.addEventListener('load', () => {
            log('üöÄ Performance test dashboard initialized');
            checkGameStatus();
            startPerformanceMonitoring();
        });

        // Listen for game ready event
        window.addEventListener('phaser-game-ready', () => {
            gameReady = true;
            log('‚úÖ Phaser game is ready');
            updateSystemStatus();
        });

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            logLines.push(logMessage);
            
            // Keep only last 50 lines
            if (logLines.length > 50) {
                logLines.shift();
            }
            
            const logOutput = document.getElementById('log-output');
            logOutput.innerHTML = logLines.join('\n');
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        function clearLog() {
            logLines = [];
            document.getElementById('log-output').innerHTML = '';
        }

        function checkGameStatus() {
            if (typeof window.getCollisionStats === 'function') {
                gameReady = true;
                updateSystemStatus();
            } else {
                setTimeout(checkGameStatus, 1000);
            }
        }

        function updateSystemStatus() {
            const gameReadyElement = document.getElementById('game-ready-value');
            
            if (gameReady) {
                gameReadyElement.textContent = 'Ready ‚úÖ';
                
                // Check individual systems
                try {
                    const stats = window.getCollisionStats();
                    
                    // Update collision optimizer status
                    const optimizerStatus = document.getElementById('collision-optimizer-status');
                    const optimizerValue = document.getElementById('collision-optimizer-value');
                    if (stats.optimizerStats) {
                        optimizerStatus.className = 'status-indicator status-active';
                        optimizerValue.textContent = 'Active ‚úÖ';
                    } else {
                        optimizerStatus.className = 'status-indicator status-warning';
                        optimizerValue.textContent = 'Fallback Mode ‚ö†Ô∏è';
                    }
                    
                    // Update player debouncer status
                    const debouncerStats = window.getPlayerInfoStats();
                    const debouncerStatus = document.getElementById('player-debouncer-status');
                    const debouncerValue = document.getElementById('player-debouncer-value');
                    if (debouncerStats && !debouncerStats.error) {
                        debouncerStatus.className = 'status-indicator status-active';
                        debouncerValue.textContent = 'Active ‚úÖ';
                    } else {
                        debouncerStatus.className = 'status-indicator status-warning';
                        debouncerValue.textContent = 'Not Available ‚ö†Ô∏è';
                    }
                    
                    // Update multi-collision manager status
                    const multiStatus = document.getElementById('multi-collision-status');
                    const multiValue = document.getElementById('multi-collision-value');
                    if (stats.multiPlayerStats) {
                        multiStatus.className = 'status-indicator status-active';
                        multiValue.textContent = 'Active ‚úÖ';
                    } else {
                        multiStatus.className = 'status-indicator status-warning';
                        multiValue.textContent = 'Not Available ‚ö†Ô∏è';
                    }
                    
                } catch (error) {
                    log(`‚ùå Error checking system status: ${error.message}`);
                }
            } else {
                gameReadyElement.textContent = 'Waiting...';
            }
        }

        function startPerformanceMonitoring() {
            updateInterval = setInterval(() => {
                if (gameReady) {
                    updatePerformanceMetrics();
                }
            }, 1000);
        }

        function updatePerformanceMetrics() {
            try {
                const stats = window.getCollisionStats();
                const playerStats = window.getPlayerInfoStats();
                
                // Update collision metrics
                if (stats.optimizerStats) {
                    document.getElementById('active-collisions').textContent = stats.optimizerStats.activeCollisions || 0;
                    document.getElementById('checks-per-second').textContent = stats.optimizerStats.checksPerSecond || 0;
                    document.getElementById('average-check-time').textContent = 
                        (stats.optimizerStats.averageCheckTime || 0).toFixed(2) + 'ms';
                    document.getElementById('frame-drops').textContent = stats.optimizerStats.frameDrops || 0;
                    document.getElementById('spatial-grid-cells').textContent = stats.optimizerStats.spatialGridCells || 0;
                } else {
                    document.getElementById('active-collisions').textContent = stats.currentCollisions || 0;
                }
                
                // Update player info metrics
                if (playerStats && !playerStats.error) {
                    document.getElementById('queued-updates').textContent = playerStats.queueSize || 0;
                }
                
            } catch (error) {
                log(`‚ö†Ô∏è Error updating metrics: ${error.message}`);
            }
        }

        // Test Functions
        function testCollisionPerformance() {
            log('üß™ Starting collision performance test...');
            
            try {
                const startTime = performance.now();
                
                // Simulate multiple collision checks
                for (let i = 0; i < 100; i++) {
                    if (typeof window.getCurrentCollisions === 'function') {
                        window.getCurrentCollisions();
                    }
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                
                log(`‚úÖ Collision performance test completed in ${duration.toFixed(2)}ms`);
                log(`üìä Average per check: ${(duration / 100).toFixed(2)}ms`);
                
            } catch (error) {
                log(`‚ùå Collision performance test failed: ${error.message}`);
            }
        }

        function testPlayerInfoDebouncing() {
            log('üß™ Starting player info debouncing test...');
            
            try {
                // Simulate rapid player info updates
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        if (typeof window.forcePlayerInfoUpdate === 'function') {
                            window.forcePlayerInfoUpdate(`test-player-${i % 5}`);
                        }
                    }, i * 10); // 10ms intervals
                }
                
                log('‚úÖ Player info debouncing test initiated (50 rapid updates)');
                
                setTimeout(() => {
                    const stats = window.getPlayerInfoStats();
                    if (stats && !stats.error) {
                        log(`üìä Debouncer stats: Queue size: ${stats.queueSize}, Pending: ${stats.pendingUpdates}`);
                    }
                }, 2000);
                
            } catch (error) {
                log(`‚ùå Player info debouncing test failed: ${error.message}`);
            }
        }

        function testMultiPlayerCollisions() {
            log('üß™ Starting multi-player collision test...');
            
            try {
                if (typeof window.testCollisionSystem === 'function') {
                    window.testCollisionSystem();
                    log('‚úÖ Multi-player collision test initiated');
                } else {
                    log('‚ö†Ô∏è testCollisionSystem function not available');
                }
                
            } catch (error) {
                log(`‚ùå Multi-player collision test failed: ${error.message}`);
            }
        }

        function stressTestCollisions() {
            log('üß™ Starting collision stress test (100 simulated players)...');
            
            try {
                // This would need to be implemented in the game
                log('‚ö†Ô∏è Stress test not yet implemented in game code');
                
            } catch (error) {
                log(`‚ùå Stress test failed: ${error.message}`);
            }
        }

        function clearAllCollisions() {
            log('üßπ Clearing all collisions...');
            
            try {
                if (typeof window.clearAllCollisions === 'function') {
                    const success = window.clearAllCollisions();
                    if (success) {
                        log('‚úÖ All collisions cleared successfully');
                    } else {
                        log('‚ö†Ô∏è Failed to clear collisions');
                    }
                } else {
                    log('‚ö†Ô∏è clearAllCollisions function not available');
                }
                
            } catch (error) {
                log(`‚ùå Error clearing collisions: ${error.message}`);
            }
        }

        function updateCollisionSensitivity(value) {
            document.getElementById('sensitivity-value').textContent = value + 'px';
            
            try {
                if (typeof window.setCollisionSensitivity === 'function') {
                    const success = window.setCollisionSensitivity(parseInt(value));
                    if (success) {
                        log(`‚öôÔ∏è Collision sensitivity updated to ${value}px`);
                    } else {
                        log(`‚ö†Ô∏è Failed to update collision sensitivity`);
                    }
                }
            } catch (error) {
                log(`‚ùå Error updating collision sensitivity: ${error.message}`);
            }
        }

        function updateMaxCollisions(value) {
            try {
                if (typeof window.setMaxSimultaneousCollisions === 'function') {
                    const success = window.setMaxSimultaneousCollisions(parseInt(value));
                    if (success) {
                        log(`‚öôÔ∏è Max simultaneous collisions updated to ${value}`);
                    } else {
                        log(`‚ö†Ô∏è Failed to update max simultaneous collisions`);
                    }
                }
            } catch (error) {
                log(`‚ùå Error updating max collisions: ${error.message}`);
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html>